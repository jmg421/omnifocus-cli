/*{
    "author": "OmniFocus CLI",
    "targets": ["omnifocus"],
    "type": "action",
    "identifier": "com.jmg.exportomnifocus.v11.final",
    "version": "1.2.2",
    "description": "Exports OmniFocus database to JSON.",
    "label": "Export Full DB to JSON (v11.final)",
    "mediumLabel": "Export Full DB to JSON (v11.final)",
    "longLabel": "Export Full Database to JSON (v11.final)",
    "paletteLabel": "Export Full DB to JSON (v11.final)",
    "image": "tray.and.arrow.up.fill" 
}*/
(() => {
    // Preferences object - for file saving bookmark (not used in FileSaver version directly for path, but good to have)
    // var preferences = new Preferences(); // Can be re-enabled if we add prefs back

    var action = new PlugIn.Action(async function(argument) {
        // --- VERY EARLY DEBUGGING ---
        console.log("--- GLOBAL OBJECT DEBUG ---");
        try {
            console.log("Type of app: " + typeof app);
            if (typeof app !== 'undefined' && app !== null) {
                console.log("Type of app.document: " + typeof app.document);
                if (typeof app.document !== 'undefined' && app.document !== null) {
                    console.log("Type of app.document.database: " + typeof app.document.database);
                } else {
                    console.log("app.document IS undefined or null");
                }
            } else {
                console.log("app IS undefined or null");
            }
            console.log("Type of Database: " + typeof Database);
            if (typeof Database !== 'undefined' && Database !== null) {
                console.log("Type of Database.current: " + typeof Database.current);
            } else {
                console.log("Database IS undefined or null");
            }
            console.log("Type of flattenedTasks: " + typeof flattenedTasks + (typeof flattenedTasks !== 'undefined' && flattenedTasks !== null ? (", Length: " + flattenedTasks.length) : ""));
            console.log("Type of inbox: " + typeof inbox + (typeof inbox !== 'undefined' && inbox !== null ? (", Length: " + inbox.length) : ""));
            console.log("Type of tags: " + typeof tags + (typeof tags !== 'undefined' && tags !== null ? (", Length: " + tags.length) : ""));
    
        } catch (e) {
            console.error("Error during global object debug: " + e.toString());
        }
        console.log("--- END GLOBAL OBJECT DEBUG ---");
        // --- END VERY EARLY DEBUGGING ---

        console.log("[DEBUG_V1.2.2] Action started.");

        // --- Parameter Handling ---
        let criteria = { type: 'full_dump', hideCompleted: false }; // Default criteria
        if (argument && typeof argument === 'string' && argument.trim() !== "") {
            try {
                const parsedArg = JSON.parse(argument);
                // Basic validation of parsed criteria
                if (parsedArg && typeof parsedArg.type === 'string') {
                    criteria = parsedArg;
                    console.log("[DEBUG_V1.2.2] Received criteria: " + JSON.stringify(criteria));
                } else {
                    console.warn("[DEBUG_V1.2.2] Parsed argument is not a valid criteria object. Falling back to full_dump. Arg: " + argument);
                }
            } catch (e) {
                console.error("[DEBUG_V1.2.2] Error parsing argument JSON: " + e.toString() + ". Falling back to full_dump. Arg: " + argument);
            }
        } else {
            console.log("[DEBUG_V1.2.2] No argument or empty argument received. Performing full_dump by default.");
        }

        try {
            // --- Helper Functions ---
            const formatDate = (date) => date ? date.toISOString() : null;

            const getTaskStatusString = (status) => {
                if (status === Task.Status.Active) return "Active";
                if (status === Task.Status.Blocked) return "Blocked";
                if (status === Task.Status.Dropped) return "Dropped";
                if (status === Task.Status.Completed) return "Completed";
                // Next, Available, DueSoon are transient/derived for the main status
                return "Unknown"; 
            };

            const getProjectStatusString = (status) => {
                if (status === Project.Status.Active) return "Active";
                if (status === Project.Status.Done) return "Done";
                if (status === Project.Status.Dropped) return "Dropped";
                if (status === Project.Status.OnHold) return "OnHold";
                return "Unknown";
            };

            const getFolderStatusString = (status) => {
                if (status === Folder.Status.Active) return "Active";
                if (status === Folder.Status.Dropped) return "Dropped";
                return "Unknown";
            };

            const getPermalink = (object) => `omnifocus:///task/${object.id.primaryKey}`;

            const getRepetitionMethodString = (method) => {
                if (method === Task.RepetitionMethod.Fixed) return "Fixed";
                if (method === Task.RepetitionMethod.StartDate) return "StartDate";
                if (method === Task.RepetitionMethod.CompletionDate) return "CompletionDate";
                return "Unknown";
            };

            const ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);

            const shouldSkipTaskForFullDump = (task) => {
                // MODIFIED: Only skip explicitly dropped tasks for a truly comprehensive export
                // const effectivelyCompleted = task.effectiveCompletionDate !== null;
                // const oldAndCompleted = effectivelyCompleted && task.effectiveCompletionDate < ninetyDaysAgo;
                // return task.taskStatus === Task.Status.Dropped || oldAndCompleted;
                return task.taskStatus === Task.Status.Dropped;
            };
            
            const taskToJsonFullDump = (task) => { 
                if (shouldSkipTaskForFullDump(task)) return null;
                let children = [];
                if (task.children && task.children.length > 0) {
                    children = task.children.map(child => taskToJsonFullDump(child)).filter(child => child !== null);
                }
                // Debug log for non-completed tasks being exported
                if (task.effectiveCompletionDate === null && task.taskStatus !== Task.Status.Dropped) {
                    // console.log(`[NON-COMPLETED EXPORT] ID: ${task.id.primaryKey}, Name: ${task.name}, Status: ${getTaskStatusString(task.taskStatus)}, OFStatus: ${task.taskStatus.toString()}`);
                }
                return {
                    id: task.id.primaryKey, name: task.name, type: "Task",
                    status: getTaskStatusString(task.taskStatus),
                    permalink: getPermalink(task),
                    completed: task.effectiveCompletionDate !== null,
                    completionDate: formatDate(task.effectiveCompletionDate),
                    dueDate: formatDate(task.effectiveDueDate),
                    deferDate: formatDate(task.effectiveDeferDate),
                    flagged: task.flagged, notes: task.note,
                    tags: task.tags.map(tag => tag.name),
                    tagIds: task.tags.map(tag => tag.id.primaryKey),
                    estimatedMinutes: task.estimatedMinutes,
                    sequential: task.sequential, 
                    repetitionRule: task.repetitionRule ? {
                        method: getRepetitionMethodString(task.repetitionRule.method),
                        rule: task.repetitionRule.ruleString,
                    } : null,
                    children: children,
                    projectId: task.containingProject ? task.containingProject.id.primaryKey : null,
                    projectName: task.containingProject ? task.containingProject.name : null,
                    parentId: task.parentTask ? task.parentTask.id.primaryKey : null,
                };
            };

            const shouldSkipProjectForFullDump = (project) => {
                // MODIFIED: Only skip explicitly dropped projects
                // const effectivelyCompleted = project.effectiveCompletedDate !== null;
                // const oldAndCompleted = (project.status === Project.Status.Done || effectivelyCompleted) && project.effectiveCompletedDate < ninetyDaysAgo;
                // return project.status === Project.Status.Dropped || oldAndCompleted;
                return project.status === Project.Status.Dropped;
            };
            
            const projectTasksCache = new Map();
            const getTasksForProjectFullDump = (projectId, reliableProjectsArrayArg) => {
                if (projectTasksCache.has(projectId)) {
                    return projectTasksCache.get(projectId);
                }
                const tasksForProject = (typeof flattenedTasks !== 'undefined' && flattenedTasks !== null) ?
                    flattenedTasks
                    .filter(task => task.containingProject && task.containingProject.id.primaryKey === projectId && !task.parentTask) 
                    .map(task => taskToJsonFullDump(task))
                    .filter(task => task !== null) : [];
                projectTasksCache.set(projectId, tasksForProject);
                return tasksForProject;
            };

            const projectToJsonFullDump = (project, reliableProjectsArrayArg) => {
                // +++ ENTRY LOGGING +++
                console.log(`[projectToJsonFullDump ENTER] Processing Project: '${project.name}', ID: '${project.id.primaryKey}', Status: ${getProjectStatusString(project.status)}`);
                if (project.id.primaryKey === 'gbUwfPGfyjw' || project.name.toLowerCase().includes('cortex biomed')) {
                    console.log(`[projectToJsonFullDump ENTER] *** Target 'Cortex BioMed' IS BEING PROCESSED by projectToJsonFullDump ***`);
                }
                // +++ END ENTRY LOGGING +++

                if (shouldSkipProjectForFullDump(project)) {
                    console.log(`[projectToJsonFullDump SKIP] Project '${project.name}' (ID: '${project.id.primaryKey}') SKIPPED by shouldSkipProjectForFullDump.`);
                    return null;
                }
                
                const tasks = getTasksForProjectFullDump(project.id.primaryKey, reliableProjectsArrayArg);
                // Debug log for task count
                if (project.id.primaryKey === 'gbUwfPGfyjw' || project.name.toLowerCase().includes('cortex biomed')) {
                    console.log(`[projectToJsonFullDump CORTEX_TASKS] Cortex BioMed - Task count from getTasksForProjectFullDump: ${tasks.length}`);
                    // You could even log the tasks themselves if needed: console.log(JSON.stringify(tasks));
                }

                // Skip project if it has no tasks after filtering and is not explicitly Active or OnHold
                // (This helps remove empty old projects that weren't explicitly Dropped but have no relevant content)
                // if (tasks.length === 0 && project.status !== Project.Status.Active && project.status !== Project.Status.OnHold) {
                //     console.log(`[SKIPPING EMPTY PROJECT] ID: ${project.id.primaryKey}, Name: ${project.name}, Status: ${getProjectStatusString(project.status)}`);
                //     return null;
                // }
                return {
                    id: project.id.primaryKey, name: project.name, type: "Project",
                    status: getProjectStatusString(project.status),
                    permalink: getPermalink(project),
                    completed: project.effectiveCompletedDate !== null,
                    completionDate: formatDate(project.effectiveCompletedDate),
                    deferDate: formatDate(project.deferDate),
                    dueDate: formatDate(project.dueDate),
                    flagged: project.flagged, notes: project.note,
                    sequential: project.sequential,
                    tasks: tasks, 
                    folderId: project.parentFolder ? project.parentFolder.id.primaryKey : null,
                    // note: project.note, // Duplicate, already have notes above
                };
            };
            
            const folderProjectsCache = new Map();
            const folderSubFoldersCache = new Map();

            const getProjectsForFolderFullDump = (folderId, reliableProjectsArrayArg) => {
                console.log(`[getProjectsForFolderFullDump] Getting projects for Folder ID: '${folderId}'`); // Log folder ID
                if (folderProjectsCache.has(folderId)) {
                    return folderProjectsCache.get(folderId);
                }
                const projectsInFolder = (typeof reliableProjectsArrayArg !== 'undefined' && reliableProjectsArrayArg !== null) ?
                    reliableProjectsArrayArg
                    .filter(p => p.parentFolder && p.parentFolder.id.primaryKey === folderId)
                    .map(p => projectToJsonFullDump(p, reliableProjectsArrayArg))
                    .filter(pJson => pJson !== null) : [];
                folderProjectsCache.set(folderId, projectsInFolder);
                return projectsInFolder;
            };

            const getSubFoldersForFolderFullDump = (folderId, reliableProjectsArrayArg) => {
                console.log(`[getSubFoldersForFolderFullDump] Getting subfolders for Parent Folder ID: '${folderId}'`); // Log parent folder ID
                if (folderSubFoldersCache.has(folderId)) {
                    return folderSubFoldersCache.get(folderId);
                }
                const subFolders = (typeof flattenedFolders !== 'undefined' && flattenedFolders !== null) ?
                    flattenedFolders 
                    .filter(f => {
                        const hasParent = f.parentFolder && f.parentFolder.id.primaryKey === folderId;
                        // if (hasParent) { // Log found subfolders
                        //     console.log(`[getSubFoldersForFolderFullDump] Found subfolder: '${f.name}' (ID: '${f.id.primaryKey}') under Parent ID: '${folderId}'`);
                        // }
                        return hasParent;
                    })
                    .map(f => {
                        console.log(`[getSubFoldersForFolderFullDump] Mapping subfolder: '${f.name}' (ID: '${f.id.primaryKey}') for Parent ID: '${folderId}'`); // Log before mapping
                        return folderToJsonFullDump(f, reliableProjectsArrayArg);
                    })
                    .filter(fJson => fJson !== null) : [];
                folderSubFoldersCache.set(folderId, subFolders);
                return subFolders;
            };

            const shouldSkipFolderForFullDump = (folder, projects, subfolders) => {
                 // MODIFIED: Only skip folder if it's dropped. If active/no status, keep even if empty.
                return folder.status === Folder.Status.Dropped;
                // return folder.status === Folder.Status.Dropped || (projects.length === 0 && subfolders.length === 0);
            };

            const folderToJsonFullDump = (folder, reliableProjectsArrayArg) => {
                console.log(`[folderToJsonFullDump ENTER] Processing Folder: '${folder.name}', ID: '${folder.id.primaryKey}'`);
                console.log(`[folderToJsonFullDump DEBUG] Type of incoming reliableProjectsArrayArg: ${typeof reliableProjectsArrayArg}`);
                if (reliableProjectsArrayArg === undefined) {
                    console.error("[folderToJsonFullDump FATAL_DEBUG] reliableProjectsArrayArg is UNDEFINED at entry!");
                }

                const projects = getProjectsForFolderFullDump(folder.id.primaryKey, reliableProjectsArrayArg);

                // Explicitly use the parameter in a new const for clarity and to test scope
                const argForSubfolderProcessing = reliableProjectsArrayArg; 
                console.log(`[folderToJsonFullDump DEBUG] Type of argForSubfolderProcessing: ${typeof argForSubfolderProcessing}`);
                if (argForSubfolderProcessing === undefined) {
                    console.error("[folderToJsonFullDump FATAL_DEBUG] argForSubfolderProcessing became UNDEFINED before call to getSubFoldersForFolderFullDump!");
                }

                const subfolders = getSubFoldersForFolderFullDump(folder.id.primaryKey, argForSubfolderProcessing); 

                if (shouldSkipFolderForFullDump(folder, projects, subfolders)) return null;
                return {
                    id: folder.id.primaryKey, name: folder.name, type: "Folder",
                    status: getFolderStatusString(folder.status),
                    folders: subfolders, 
                    projects: projects,
                    parentFolderID: folder.parentFolder ? folder.parentFolder.id.primaryKey : null,
                };
            };

            // --- END Helper Functions for Full Dump ---


            // --- Main Logic Based on Criteria ---
            let jsonOutputString = "";
            let outputSummaryMessage = "";

            console.log(`[DEBUG_V1.2.2] Criteria comparison: criteria.type="${criteria.type}", typeof="${typeof criteria.type}"`);
            
            if (criteria.type === 'next_actions') {
                console.log("[DEBUG_V1.2.2] Processing 'next_actions' request.");
                
                const filteredOutput = {
                    version: "omni-js-filtered-1.1.1",
                    timestamp: new Date().toISOString(),
                    criteriaUsed: criteria,
                    tasks: [],
                    projects: {}, 
                    folders: {},  
                    tags: {},     
                    inboxTasks: [], 
                    taskTags: [] 
                };

                const relevantTaskIds = new Set();
                const relevantProjectIds = new Set();
                const relevantFolderIds = new Set();
                const relevantTagIds = new Set();

                const taskToJsonForFiltered = (task) => {
                    if (!task || !task.id || !task.id.primaryKey) return null;
                    return {
                        id: task.id.primaryKey,
                        name: task.name,
                        status: getTaskStatusString(task.taskStatus), 
                        note: task.note || "",
                        dueDate: formatDate(task.effectiveDueDate),
                        deferDate: formatDate(task.effectiveDeferDate),
                        completedDate: formatDate(task.effectiveCompletionDate),
                        projectId: task.containingProject ? task.containingProject.id.primaryKey : null,
                        parentId: task.parentTask ? task.parentTask.id.primaryKey : null,
                        tagIds: task.tags.map(t => t.id.primaryKey),
                        flagged: task.flagged,
                        estimatedMinutes: task.estimatedMinutes,
                    };
                };
                
                const allTasksToConsider = flattenedTasks.slice(); 
                if (typeof inbox !== 'undefined' && inbox !== null && typeof inbox.forEach === 'function') {
                     inbox.forEach(task => allTasksToConsider.push(task));
                } else if (typeof inbox !== 'undefined' && inbox !== null && typeof inbox.apply === 'function') {
                    inbox.apply(task => allTasksToConsider.push(task));
                } else {
                    console.warn("[DEBUG_V1.2.2] (next_actions) 'inbox' is undefined or not iterable. Cannot add inbox tasks to consideration.");
                }


                allTasksToConsider.forEach(task => {
                    if (!task || !task.id) return; 

                    let isNextAction = false;
                    const taskStatus = task.taskStatus;

                    if (taskStatus === Task.Status.Available || taskStatus === Task.Status.Active || taskStatus === Task.Status.DueSoon || taskStatus === Task.Status.Next) {
                        isNextAction = true;
                    }
                    
                    if (criteria.hideCompleted && (taskStatus === Task.Status.Completed || taskStatus === Task.Status.Dropped)) {
                        isNextAction = false;
                    }
                    if (taskStatus === Task.Status.Dropped) { 
                        isNextAction = false;
                    }
                    
                    if (!task.flagged && task.effectiveDeferDate && task.effectiveDeferDate > new Date()) {
                         isNextAction = false;
                    }


                    if (isNextAction) {
                        const taskJson = taskToJsonForFiltered(task);
                        if (!taskJson) return;

                        if (taskJson.projectId) {
                            filteredOutput.tasks.push(taskJson);
                        } else {
                            filteredOutput.inboxTasks.push(taskJson);
                        }
                        
                        relevantTaskIds.add(taskJson.id);
                        if (taskJson.projectId) relevantProjectIds.add(taskJson.projectId);
                        (taskJson.tagIds || []).forEach(tagId => relevantTagIds.add(tagId));
                        
                        (taskJson.tagIds || []).forEach(tagId => {
                            filteredOutput.taskTags.push({ taskId: taskJson.id, tagId: tagId });
                        });
                    }
                });
                console.log(`[DEBUG_V1.2.2] Filtered ${relevantTaskIds.size} next action tasks.`);

                relevantProjectIds.forEach(projId => {
                    const project = flattenedProjects.find(p => p.id.primaryKey === projId); 
                    if (project) {
                        filteredOutput.projects[projId] = {
                            id: project.id.primaryKey,
                            name: project.name,
                            status: getProjectStatusString(project.status), 
                            tasks: [], 
                            note: project.note || "",
                            dueDate: formatDate(project.dueDate), 
                            deferDate: formatDate(project.deferDate),
                            completedDate: formatDate(project.effectiveCompletedDate),
                            flagged: project.flagged,
                        };
                        if (project.parentFolder) {
                            relevantFolderIds.add(project.parentFolder.id.primaryKey);
                        }
                    }
                });

                const processedFolderIds = new Set(); 
                let folderQueue = Array.from(relevantFolderIds);
                while(folderQueue.length > 0) {
                    const folderId = folderQueue.shift();
                    if (!folderId || processedFolderIds.has(folderId)) continue;

                    const folder = flattenedFolders.find(f => f.id.primaryKey === folderId); 
                    if (folder) {
                         filteredOutput.folders[folderId] = {
                            id: folder.id.primaryKey,
                            name: folder.name,
                            parentFolderID: folder.parentFolder ? folder.parentFolder.id.primaryKey : null,
                        };
                        processedFolderIds.add(folderId);
                        if (folder.parentFolder && !processedFolderIds.has(folder.parentFolder.id.primaryKey)) {
                            folderQueue.push(folder.parentFolder.id.primaryKey); 
                        }
                    }
                }
                
                relevantTagIds.forEach(tagId => {
                    const tag = tags.find(t => t.id.primaryKey === tagId); 
                    if (tag) {
                        filteredOutput.tags[tagId] = {
                            id: tag.id.primaryKey,
                            name: tag.name,
                        };
                    }
                });
                
                jsonOutputString = JSON.stringify(filteredOutput, null, 2);
                outputSummaryMessage = `SUCCESS: Filtered 'next_actions' data copied to clipboard. Tasks: ${filteredOutput.tasks.length + filteredOutput.inboxTasks.length}. JSON length: ${jsonOutputString.length}`;
                console.log(`[DEBUG_V1.2.2] Next Actions processing complete. Tasks: ${filteredOutput.tasks.length + filteredOutput.inboxTasks.length}, Projects: ${Object.keys(filteredOutput.projects).length}, Folders: ${Object.keys(filteredOutput.folders).length}, Tags: ${Object.keys(filteredOutput.tags).length}.`);

            } else if (criteria.type === 'flagged_analysis') {
                console.log("[DEBUG_V1.2.2] Processing 'flagged_analysis' request.");
                
                // FLAGGED ITEMS ANALYSIS
                const now = new Date();
                
                // Get all flagged tasks (avoid duplicates using Set of IDs)
                const allFlaggedTasks = [];
                const seenTaskIds = new Set();
                
                // Add inbox flagged tasks
                if (typeof inbox !== 'undefined' && inbox !== null && typeof inbox.forEach === 'function') {
                    inbox.forEach(task => {
                        if (task.flagged && !seenTaskIds.has(task.id.primaryKey)) {
                            allFlaggedTasks.push(task);
                            seenTaskIds.add(task.id.primaryKey);
                        }
                    });
                }
                
                // Add project flagged tasks (skip if already seen)
                if (typeof flattenedTasks !== 'undefined' && flattenedTasks !== null) {
                    flattenedTasks.forEach(task => {
                        if (task.flagged && !seenTaskIds.has(task.id.primaryKey)) {
                            allFlaggedTasks.push(task);
                            seenTaskIds.add(task.id.primaryKey);
                        }
                    });
                }

                // Get flagged projects
                const flaggedProjects = [];
                if (typeof flattenedProjects !== 'undefined' && flattenedProjects !== null) {
                    flattenedProjects.forEach(project => {
                        if (project.flagged) flaggedProjects.push(project);
                    });
                }

                // Enhanced task conversion with analysis fields
                const taskToAnalysisJSON = (task) => {
                    const proj = task.containingProject;
                    const parent = task.parentTask;
                    return {
                        id: task.id.primaryKey,
                        name: task.name,
                        note: task.note || "",
                        status: getTaskStatusString(task.taskStatus),
                        taskStatus: task.taskStatus.toString(),
                        flagged: task.flagged,
                        completed: task.effectiveCompletionDate !== null,
                        dueDate: formatDate(task.effectiveDueDate),
                        deferDate: formatDate(task.effectiveDeferDate),
                        completionDate: formatDate(task.effectiveCompletionDate),
                        estimatedMinutes: task.estimatedMinutes,
                        projectId: proj ? proj.id.primaryKey : null,
                        projectName: proj ? proj.name : 'Inbox',
                        parentId: parent ? parent.id.primaryKey : null,
                        childIds: task.children ? task.children.map(t => t.id.primaryKey) : [],
                        tagIds: task.tags.map(t => t.id.primaryKey),
                        tagNames: task.tags.map(t => t.name),
                        // Analysis fields
                        isOverdue: task.effectiveDueDate && task.effectiveDueDate < now && !task.effectiveCompletionDate,
                        isDueToday: task.effectiveDueDate && task.effectiveDueDate.toDateString() === now.toDateString(),
                        hasDueDate: !!task.effectiveDueDate,
                        hasChildren: task.children && task.children.length > 0,
                        isActionable: task.taskStatus === Task.Status.Available || task.taskStatus === Task.Status.Next,
                    };
                };

                const projectAnalysisJSON = (project) => ({
                    id: project.id.primaryKey,
                    name: project.name,
                    status: getProjectStatusString(project.status),
                    flagged: project.flagged,
                    note: project.note || "",
                    dueDate: formatDate(project.dueDate),
                    deferDate: formatDate(project.deferDate),
                    completionDate: formatDate(project.effectiveCompletedDate),
                    estimatedMinutes: project.estimatedMinutes,
                    taskCount: project.flattenedTasks ? project.flattenedTasks.length : 0,
                    flaggedTaskCount: project.flattenedTasks ? project.flattenedTasks.filter(t => t.flagged).length : 0,
                });

                // Convert to JSON with analysis
                const flaggedTasks = allFlaggedTasks.map(taskToAnalysisJSON);
                const flaggedProjectsData = flaggedProjects.map(projectAnalysisJSON);

                // Categorize flagged items for analysis
                const categories = {
                    actionableNextActions: flaggedTasks.filter(t => t.isActionable && !t.hasChildren),
                    overdueItems: flaggedTasks.filter(t => t.isOverdue),
                    dueTodayItems: flaggedTasks.filter(t => t.isDueToday),
                    referenceCategories: flaggedTasks.filter(t => 
                        t.name.toLowerCase().includes('process') ||
                        t.name.toLowerCase().includes('measures') ||
                        t.name.toLowerCase().includes('coordination') ||
                        t.name.toLowerCase().includes('advocacy') ||
                        t.hasChildren
                    ),
                    familyMember5HealingItems: flaggedTasks.filter(t => 
                        t.projectName && t.projectName.toLowerCase().includes('family member 5 healing')
                    ),
                    projectManagement: flaggedTasks.filter(t =>
                        t.name.toLowerCase().includes('review') ||
                        t.name.toLowerCase().includes('plan') ||
                        t.name.toLowerCase().includes('organize')
                    ),
                    inboxItems: flaggedTasks.filter(t => t.projectName === 'Inbox'),
                };

                const flaggedAnalysisOutput = {
                    version: "flagged-analysis-1.0",
                    timestamp: now.toISOString(),
                    criteriaUsed: criteria,
                    summary: {
                        totalFlaggedTasks: flaggedTasks.length,
                        totalFlaggedProjects: flaggedProjectsData.length,
                        actionableNextActions: categories.actionableNextActions.length,
                        overdueItems: categories.overdueItems.length,
                        dueTodayItems: categories.dueTodayItems.length,
                        referenceCategories: categories.referenceCategories.length,
                        familyMember5HealingItems: categories.familyMember5HealingItems.length,
                        inboxItems: categories.inboxItems.length,
                    },
                    flaggedTasks: flaggedTasks,
                    flaggedProjects: flaggedProjectsData,
                    categories: categories,
                    recommendations: {
                        shouldUnflagReferenceCategories: categories.referenceCategories.length > 0,
                        shouldProcessInboxItems: categories.inboxItems.length > 0,
                        shouldAddresOverdueItems: categories.overdueItems.length > 0,
                        shouldFocusOnActionableItems: categories.actionableNextActions.length > 0,
                    }
                };

                jsonOutputString = JSON.stringify(flaggedAnalysisOutput, null, 2);
                outputSummaryMessage = `SUCCESS: Flagged analysis data copied to clipboard. Flagged Tasks: ${flaggedTasks.length}, Flagged Projects: ${flaggedProjectsData.length}. JSON length: ${jsonOutputString.length}`;
                console.log(`[DEBUG_V1.2.2] Flagged analysis processing complete. Tasks: ${flaggedTasks.length}, Projects: ${flaggedProjectsData.length}, Actionable: ${categories.actionableNextActions.length}, Overdue: ${categories.overdueItems.length}.`);

            } else { // Default to 'full_dump'
                console.log("[DEBUG_V1.2.2] Processing 'full_dump' request (or fallback).");
                
                // +++ START PROJECT DEBUGGING LOOP +++
                let actualProjectCountViaForEach = 0;
                if (typeof flattenedProjects !== 'undefined' && flattenedProjects !== null && typeof flattenedProjects.forEach === 'function') {
                    console.log("[PROJECT_DEBUG] Iterating through 'flattenedProjects' (forEach loop)... Reports .length as: " + flattenedProjects.length);
                    flattenedProjects.forEach((proj, index) => {
                        actualProjectCountViaForEach++;
                        if (proj && proj.name) {
                            let statusStr = 'Unknown Status';
                            try { statusStr = getProjectStatusString(proj.status); } catch (e) { statusStr = `Error getting status: ${proj.status}`; }
                            // More concise logging for general projects
                            if (index % 20 === 0 || (proj.name && proj.name.toLowerCase().includes('cortex biomed'))) { // Log first, then every 20th, and always Cortex
                                console.log(`[PROJECT_DEBUG] Index: ${index}, Name: '${proj.name}', Status: ${statusStr}, ID: ${proj.id.primaryKey}`);
                            }
                            if (proj.name.toLowerCase().includes('cortex biomed')) {
                                console.log(`[PROJECT_DEBUG] *** Found 'Cortex BioMed' (or similar) in flattenedProjects: Name: ${proj.name}, Status: ${statusStr} ***`);
                            }
                        }
                    });
                    console.log(`[PROJECT_DEBUG] Finished iterating through 'flattenedProjects' via forEach. Counted: ${actualProjectCountViaForEach} projects.`);
                } else {
                    console.log("[PROJECT_DEBUG] 'flattenedProjects' is undefined, null, or not iterable for forEach debug.");
                }
                // +++ END PROJECT DEBUGGING LOOP +++

                // +++ START RELIABLE PROJECT ARRAY CONSTRUCTION +++
                const reliableProjectsArray = [];
                if (typeof flattenedProjects !== 'undefined' && flattenedProjects !== null && typeof flattenedProjects.forEach === 'function') {
                    flattenedProjects.forEach(proj => {
                        if (proj && typeof proj === 'object' && proj.id) { // Basic check for a valid project-like object
                           reliableProjectsArray.push(proj);
                        }
                    });
                    console.log(`[DEBUG_V1.2.2] Constructed 'reliableProjectsArray' with ${reliableProjectsArray.length} projects (this count is from forEach iteration).`);
                } else {
                    console.warn("[DEBUG_V1.2.2] 'flattenedProjects' was not suitable for building 'reliableProjectsArray'.");
                }

                // +++ DUMP FLATTENEDFOLDERS +++
                console.log("[FLATTENED_FOLDERS_DUMP] Iterating all folders in flattenedFolders (Count: " + (flattenedFolders ? flattenedFolders.length : 'N/A') + "):");
                if (typeof flattenedFolders !== 'undefined' && flattenedFolders !== null && typeof flattenedFolders.forEach === 'function') {
                    flattenedFolders.forEach(folder => {
                        let parentInfo = "No parentFolder property or parentFolder is null/undefined";
                        if (folder.parentFolder && folder.parentFolder.id && folder.parentFolder.name) {
                            parentInfo = `Parent Name: '${folder.parentFolder.name}', Parent ID: '${folder.parentFolder.id.primaryKey}'`;
                        } else if (folder.parentFolder) {
                            parentInfo = `Parent exists but is not a full object: ${folder.parentFolder}`;
                        } else if (folder.hasOwnProperty('parentFolder')) {
                            parentInfo = "parentFolder property exists but is null or undefined.";
                        }

                        console.log(`  - Folder: '${folder.name}' (ID: ${folder.id.primaryKey}), ${parentInfo}`);
                        if (folder.id.primaryKey === "iEhR4VGgGbp") { // Family Member 1's ID
    console.log(`    *** THIS IS THE 'Family Member 1' FOLDER (ID iEhR4VGgGbp) as seen in flattenedFolders ***`);
                        }
                        if (folder.id.primaryKey === "amGxjZLKRBV") { // Family's ID
                             console.log(`    *** THIS IS THE 'Family' FOLDER (ID amGxjZLKRBV) as seen in flattenedFolders ***`);
                        }
                    });
                } else {
                    console.log("[FLATTENED_FOLDERS_DUMP] flattenedFolders is not iterable or undefined.");
                }
                // +++ END DUMP FLATTENEDFOLDERS +++

                // +++ PRE-FILTER VALIDATION FOR CORTEX BIOMED +++
                const cortexProjectObject = reliableProjectsArray.find(p => p.id.primaryKey === 'gbUwfPGfyjw');
                if (cortexProjectObject) {
                    console.log(`[PRE-FILTER VALIDATION] Cortex BioMed (gbUwfPGfyjw) found in reliableProjectsArray.`);
                    console.log(`    - Name: ${cortexProjectObject.name}`);
                    console.log(`    - Status: ${getProjectStatusString(cortexProjectObject.status)}`);
                    console.log(`    - Has parentFolder property: ${cortexProjectObject.hasOwnProperty('parentFolder')}`);
                    if (cortexProjectObject.hasOwnProperty('parentFolder')) {
                        console.log(`    - parentFolder value: ${cortexProjectObject.parentFolder}`);
                        if (cortexProjectObject.parentFolder) {
                            console.log(`    - parentFolder ID: ${cortexProjectObject.parentFolder.id.primaryKey}`);
                            console.log(`    - parentFolder Name: ${cortexProjectObject.parentFolder.name}`);
                        }
                    }
                    // Log properties of the project object to see its structure
                    // console.log(`    - Cortex Project Object Keys: ${Object.keys(cortexProjectObject).join(', ')}`);
                    // try { console.log(`    - Cortex Project Object (Full): ${JSON.stringify(cortexProjectObject)}`); } catch (e) { console.log("Error stringifying cortexProjectObject"); }
                } else {
                    console.warn("[PRE-FILTER VALIDATION] Cortex BioMed (gbUwfPGfyjw) NOT found in reliableProjectsArray. This is unexpected!");
                }
                // +++ END PRE-FILTER VALIDATION +++

                projectTasksCache.clear();
                folderProjectsCache.clear();
                folderSubFoldersCache.clear();

                if (typeof reliableProjectsArray === 'undefined' || typeof flattenedFolders === 'undefined' || 
                    typeof flattenedTasks === 'undefined' || typeof folders === 'undefined') {
                    const msg = "One or more base collections (reliableProjectsArray, flattenedFolders, flattenedTasks, folders) are undefined for full dump.";
                    console.error(`[DEBUG_V1.2.2] CRITICAL (full_dump): ${msg}`); 
                    throw new Error(`PLUGIN_ERROR: ${msg}`);
                }
                console.log(`[DEBUG_V1.2.2] (full_dump) Base collections for export processing: reliableProjects (${reliableProjectsArray.length}), flattenedFolders (${flattenedFolders.length}), flattenedTasks (${flattenedTasks.length}), topFolders (${folders.length})`);

                if (typeof inbox === 'undefined' || inbox === null) {
                     console.warn("[DEBUG_V1.2.2] (full_dump) Global 'inbox' undefined or null.");
                } else {
                    console.log(`[DEBUG_V1.2.2] (full_dump) Inbox items: ${inbox.length !== undefined ? inbox.length : 'N/A (inbox.length undefined)'}`);
                }

                const outputFolders = folders.map(folder => folderToJsonFullDump(folder, reliableProjectsArray)).filter(folder => folder !== null);
                
                const topLevelExportedProjects = reliableProjectsArray
                    .filter(p => !p.parentFolder) 
                    .map(p => projectToJsonFullDump(p, reliableProjectsArray))
                    .filter(pJson => pJson !== null);

                let inboxExportedTasks = [];
                if (typeof inbox !== 'undefined' && inbox !== null) {
                    if (typeof inbox.forEach === 'function'){ 
                         console.log("[DEBUG_V1.2.2] (full_dump) Processing inbox using inbox.forEach().");
                         inbox.forEach(task => { 
                            const taskJSON = taskToJsonFullDump(task);
                            if (taskJSON) {
                                inboxExportedTasks.push(taskJSON);
                            }
                        });
                    } else if (typeof inbox.apply === 'function') { 
                        console.log("[DEBUG_V1.2.2] (full_dump) Processing inbox using inbox.apply() (fallback).");
                        inbox.apply(task => {
                            const taskJSON = taskToJsonFullDump(task);
                            if (taskJSON) {
                                inboxExportedTasks.push(taskJSON);
                            }
                        });
                    } else {
                        console.warn("[DEBUG_V1.2.2] (full_dump) 'inbox' object does not have .forEach or .apply. Cannot process inbox tasks.");
                    }
                } else {
                     console.warn("[DEBUG_V1.2.2] (full_dump) 'inbox' is undefined or null. Cannot process inbox tasks.");
                }
                console.log(`[DEBUG_V1.2.2] (full_dump) Processed ${inboxExportedTasks.length} inbox tasks.`);

                const allTagsExport = {};
                if (typeof tags !== 'undefined' && tags !== null && typeof tags.forEach === 'function') {
                    tags.forEach(tag => {
                        allTagsExport[tag.id.primaryKey] = {
                            id: tag.id.primaryKey,
                            name: tag.name
                        };
                    });
                } else {
                    console.warn("[DEBUG_V1.2.2] (full_dump) Global 'tags' collection is not available for full export.");
                }

                const fullOutputData = {
                    version: "omni-js-full-dump-1.2.3", // Incremented version
                    timestamp: new Date().toISOString(),
                    structure: { 
                        topLevelFolders: outputFolders, 
                        topLevelProjects: topLevelExportedProjects 
                    },
                    inboxItems: inboxExportedTasks,
                    tags: allTagsExport,
                };

                // +++ START VALIDATION LOGGING FOR CORTEX BIOMED +++
                let cortexFoundInOutputObject = false;
                const targetProjectIdValidation = "gbUwfPGfyjw"; // Cortex BioMed ID
                const targetProjectNameValidation = "cortex biomed";

                console.log(`[VALIDATION] Checking fullOutputData for Project ID: ${targetProjectIdValidation} or Name containing: ${targetProjectNameValidation}`);

                // Check topLevelProjects
                if (fullOutputData.structure && fullOutputData.structure.topLevelProjects) {
                    fullOutputData.structure.topLevelProjects.forEach(p => {
                        if (p.id === targetProjectIdValidation || (p.name && p.name.toLowerCase().includes(targetProjectNameValidation))) {
                            cortexFoundInOutputObject = true;
                            console.log(`[VALIDATION] Target project FOUND in fullOutputData.structure.topLevelProjects. Name: ${p.name}, ID: ${p.id}`);
                        }
                    });
                }

                // Recursively check projects within folders
                if (!cortexFoundInOutputObject && fullOutputData.structure && fullOutputData.structure.topLevelFolders) {
                    function findTargetInFolders(folders) {
                        if (!folders || cortexFoundInOutputObject) return; // Stop if already found
                        folders.forEach(folder => {
                            if (cortexFoundInOutputObject) return; // Stop if already found by a parallel check

                            if (folder.projects) {
                                folder.projects.forEach(p => {
                                    if (p.id === targetProjectIdValidation || (p.name && p.name.toLowerCase().includes(targetProjectNameValidation))) {
                                        cortexFoundInOutputObject = true;
                                        console.log(`[VALIDATION] Target project FOUND in fullOutputData within a folder. Folder: '${folder.name}', Project Name: '${p.name}', ID: '${p.id}'`);
                                    }
                                });
                            }
                            if (folder.folders) { // Check subfolders recursively
                                findTargetInFolders(folder.folders);
                            }
                        });
                    }
                    findTargetInFolders(fullOutputData.structure.topLevelFolders);
                }

                if (cortexFoundInOutputObject) {
                    console.log("[VALIDATION] SUCCESS: Target project was found in the final 'fullOutputData' object structure before stringification.");
                } else {
                    console.warn("[VALIDATION] FAILURE: Target project was NOT FOUND in the final 'fullOutputData' object structure before stringification.");
                }
                // +++ END VALIDATION LOGGING FOR CORTEX BIOMED +++

                console.log("[DEBUG_V1.2.2] (full_dump) Data processing complete.");

                jsonOutputString = JSON.stringify(fullOutputData, null, 2);
                outputSummaryMessage = `SUCCESS: Full database data copied to clipboard. Length: ${jsonOutputString.length}`;
            }

            try {
                if (typeof Pasteboard === 'undefined' || !Pasteboard.general) {
                    console.error("[DEBUG_V1.2.2] CRITICAL: Pasteboard.general is unavailable.");
                    throw new Error ("PLUGIN_ERROR: Pasteboard.general is not available to copy data to clipboard.");
                }

                Pasteboard.general.string = jsonOutputString;
                console.log("[DEBUG_V1.2.2] " + outputSummaryMessage);
                // return outputSummaryMessage; // For async, result is handled by promise resolution

            } catch (error) {
                console.error("[DEBUG_V1.2.2] ERROR during clipboard copy:", error.toString(), error.stack || "");
                const alert = new Alert("Clipboard Error", `Failed to copy JSON to clipboard: ${error.message}`);
                alert.show();
                // throw error; // Re-throw to indicate failure to the caller if desired
            }

        } catch (e) { 
            console.error("[DEBUG_V1.2.2] CRITICAL ERROR in action:", e.toString(), e.stack || "");
            const alert = new Alert("Plugin Error", `An error occurred: ${e.message}. Check console for details.`);
            alert.show();
            // throw e; // Re-throw to indicate failure if this is the top level of the plugin action
        }
    });

    action.validate = function(_selection, _sender){
        return true;
    };
        
    return action;
})();