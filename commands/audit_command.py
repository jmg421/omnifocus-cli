import json
import os
import datetime
import re
from typing import List, Dict, Any, Tuple
from omnifocus_api import apple_script_client
from omnifocus_api.data_models import OmniFocusTask
from ai_integration.openai_client import openai_completion
from ai_integration.anthropic_client import anthropic_completion
from ai_integration.utils.format_utils import format_task_list
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.data_loading import load_and_prepare_omnifocus_data, query_prepared_data, get_latest_json_export_path

# Define categories for task classification
CATEGORIES = {
    "REFERENCE": "Reference Material (Move to Evernote)",
    "NON_ACTIONABLE": "Non-Actionable (Consider Deleting)",
    "STALE": "Stale Tasks (Review or Delete)",
    "VAGUE": "Vague Tasks (Clarify or Delete)",
    "INCOMPLETE": "Incomplete Tasks (Need More Details)",
    "ACTIONABLE": "Actionable Tasks (Keep)",
}

def analyze_task(task: OmniFocusTask) -> str:
    """
    Analyzes a task and returns its category based on content.
    """
    # Check if it's a reference item (no action verb, contains information)
    reference_indicators = ["how to", "information", "notes on", "reference", "article", "link to"]
    if any(indicator in task.name.lower() for indicator in reference_indicators) or (task.note and len(task.note) > 100):
        return "REFERENCE"
    
    # Check for incomplete tasks (contains "incomplete" or similar phrases)
    incomplete_indicators = ["incomplete", "inprogress", "in progress", "started", "partial", "halfway", "begin", "todo"]
    if any(indicator in task.name.lower() for indicator in incomplete_indicators):
        return "INCOMPLETE"
    
    # Check if it's non-actionable (doesn't start with a verb)
    first_word = task.name.split()[0].lower() if task.name else ""
    common_verbs = ["call", "email", "write", "review", "check", "create", "schedule", "buy", "make", "finish", "complete"]
    if first_word not in common_verbs and not re.match(r'^\[.*\]', task.name):
        return "NON_ACTIONABLE"
    
    # Check if it's vague (too short, lacks specificity)
    if len(task.name.split()) < 3 and not task.note:
        return "VAGUE"
    
    # Check if it's stale (due date in the past)
    if task.due_date:
        try:
            due_date = datetime.datetime.strptime(task.due_date, "%Y-%m-%d")
            if due_date < datetime.datetime.now() - datetime.timedelta(days=14):
                return "STALE"
        except (ValueError, TypeError):
            pass  # Can't parse date, continue
    
    # Default to actionable
    return "ACTIONABLE"

def categorize_tasks(tasks: List[OmniFocusTask]) -> Dict[str, List[OmniFocusTask]]:
    """
    Categorizes tasks into groups for cleanup.
    """
    categorized = {category: [] for category in CATEGORIES.keys()}
    
    for task in tasks:
        category = analyze_task(task)
        categorized[category].append(task)
    
    return categorized

def generate_export_file(tasks: List[OmniFocusTask], filename: str = "evernote_export.txt") -> str:
    """
    Generates a file with reference material for Evernote import.
    """
    with open(filename, "w") as f:
        f.write("# OmniFocus Reference Items for Evernote\n\n")
        for i, task in enumerate(tasks):
            f.write(f"## {task.name}\n\n")
            if task.note:
                f.write(f"{task.note}\n\n")
            f.write(f"*Exported from OmniFocus task ID: {task.id}*\n\n")
            f.write("---\n\n")
    
    return os.path.abspath(filename)

def generate_cleanup_script(categorized_tasks: Dict[str, List[OmniFocusTask]], output_path: str = "cleanup_script.applescript") -> str:
    """
    Generates an AppleScript to help with bulk cleanup operations.
    """
    script_content = """-- OmniFocus Cleanup Script
-- Generated by OFCLI Audit Command
-- WARNING: Make a backup of your OmniFocus database before running this script!

tell application "OmniFocus"
    tell default document
        
        set deletedCount to 0
        set movedToSomedayCount to 0
        set taggedCount to 0
        
        -- Create a "Reference Material" project for reference items
        set refProject to missing value
        try
            set refProject to first flattened project where its name is "Reference Material"
        on error
            set refProject to make new project with properties {name:"Reference Material"}
        end try
        
        -- Create someday/maybe folder for non-actionable items
        set somedayFolder to missing value
        try
            set somedayFolder to first flattened folder where its name is "Someday/Maybe"
        on error
            set somedayFolder to make new folder with properties {name:"Someday/Maybe"}
        end try
        
        -- Create a cleanup tag
        set cleanupTag to missing value
        try
            set cleanupTag to first flattened tag where its name is "Needs_Cleanup"
        on error
            set cleanupTag to make new tag with properties {name:"Needs_Cleanup"}
        end try
        
"""
    
    # Add reference items
    if categorized_tasks["REFERENCE"]:
        script_content += "\n        -- Move reference items to Reference Material project\n"
        for task in categorized_tasks["REFERENCE"]:
            script_content += f"""        try
            set theTask to first flattened task where its id is "{task.id}"
            move theTask to end of tasks of refProject
            set deletedCount to deletedCount + 1
        on error
            -- Task not found or couldn't be moved
        end try
"""
    
    # Add incomplete items
    if categorized_tasks["INCOMPLETE"]:
        script_content += "\n        -- Tag incomplete items for review\n"
        for task in categorized_tasks["INCOMPLETE"]:
            script_content += f"""        try
            set theTask to first flattened task where its id is "{task.id}"
            add cleanupTag to tags of theTask
            set taggedCount to taggedCount + 1
        on error
            -- Task not found or couldn't be tagged
        end try
"""
    
    # Add non-actionable items
    if categorized_tasks["NON_ACTIONABLE"]:
        script_content += "\n        -- Move non-actionable items to Someday/Maybe\n"
        for task in categorized_tasks["NON_ACTIONABLE"]:
            script_content += f"""        try
            set theTask to first flattened task where its id is "{task.id}"
            move theTask to end of tasks of somedayFolder
            set movedToSomedayCount to movedToSomedayCount + 1
        on error
            -- Task not found or couldn't be moved
        end try
"""
    
    # Add vague items
    if categorized_tasks["VAGUE"]:
        script_content += "\n        -- Tag vague items for clarification\n"
        for task in categorized_tasks["VAGUE"]:
            script_content += f"""        try
            set theTask to first flattened task where its id is "{task.id}"
            add cleanupTag to tags of theTask
            set taggedCount to taggedCount + 1
        on error
            -- Task not found or couldn't be tagged
        end try
"""
    
    # Add stale items
    if categorized_tasks["STALE"]:
        script_content += "\n        -- Tag stale items for review\n"
        for task in categorized_tasks["STALE"]:
            script_content += f"""        try
            set theTask to first flattened task where its id is "{task.id}"
            add cleanupTag to tags of theTask
            set taggedCount to taggedCount + 1
        on error
            -- Task not found or couldn't be tagged
        end try
"""
    
    # Finish script
    script_content += """
        -- Display results
        display dialog "Cleanup completed:" & return & 
            deletedCount & " items moved to Reference Material" & return &
            movedToSomedayCount & " items moved to Someday/Maybe" & return &
            taggedCount & " items tagged for cleanup"
    end tell
end tell
"""
    
    # Write to file
    with open(output_path, "w") as f:
        f.write(script_content)
    
    return os.path.abspath(output_path)

def handle_audit(args):
    """
    Analyze tasks from the JSON export, optionally filtered by project.
    """
    file = getattr(args, 'file', None) or get_latest_json_export_path()
    data = load_and_prepare_omnifocus_data(file)
    if not data or not data.get("all_tasks"):
        print(f"No tasks found in {file}")
        return
    project = getattr(args, 'project', None)
    tasks = [t for t in data["all_tasks"] if (not project or t.get("projectId") == project)]
    
    # Check for cleanup script generation if it's set in args
    generate_script = getattr(args, 'generate_script', False)
    
    # Limit the number of tasks if needed
    if args.limit and len(tasks) > args.limit:
        print(f"Limiting analysis to {args.limit} tasks (out of {len(tasks)} total).")
        tasks = tasks[:args.limit]
    
    if not tasks:
        print("No tasks found to analyze.")
        return
    
    # Categorize tasks
    print(f"Analyzing {len(tasks)} tasks...")
    categorized_tasks = categorize_tasks(tasks)
    
    # Print summary
    print("\n" + "="*50)
    print("OMNIFOCUS DATABASE AUDIT SUMMARY")
    print("="*50)
    
    total_tasks = len(tasks)
    for category, category_name in CATEGORIES.items():
        cat_tasks = categorized_tasks[category]
        percentage = (len(cat_tasks) / total_tasks) * 100 if total_tasks > 0 else 0
        print(f"{category_name}: {len(cat_tasks)} tasks ({percentage:.1f}%)")
    
    print("\n" + "="*50)
    print("DETAILED BREAKDOWN")
    print("="*50)
    
    # Show detailed breakdown by category
    for category, category_name in CATEGORIES.items():
        cat_tasks = categorized_tasks[category]
        if cat_tasks:
            print(f"\n{category_name} ({len(cat_tasks)} items):")
            print("-" * len(f"{category_name} ({len(cat_tasks)} items):"))
            print(format_task_list(cat_tasks[:10]))
            if len(cat_tasks) > 10:
                print(f"... and {len(cat_tasks)-10} more.")
    
    # Export reference items if requested
    if args.export and categorized_tasks["REFERENCE"]:
        export_path = generate_export_file(categorized_tasks["REFERENCE"])
        print(f"\nExported {len(categorized_tasks['REFERENCE'])} reference items to {export_path}")
    
    # Generate cleanup script if requested
    if generate_script:
        script_path = generate_cleanup_script(categorized_tasks)
        print(f"\nGenerated AppleScript for bulk cleanup: {script_path}")
        print("Review the script carefully before running it in Script Editor!")
    
    # Provide cleanup recommendations
    print("\n" + "="*50)
    print("CLEANUP RECOMMENDATIONS")
    print("="*50)
    
    print("""
1. Reference Material: Export to Evernote, then delete from OmniFocus.
2. Non-Actionable Items: Either delete or convert to actionable tasks by adding verbs.
3. Vague Tasks: Add details to clarify what specific action is needed.
4. Incomplete Tasks: Review and update with clear next steps.
5. Stale Tasks: Either update due dates or delete if no longer relevant.
6. Actionable Tasks: Keep and organize by project or context.

For bulk operations, run:
  ofcli audit --export --limit 0     # Export all reference material
  ofcli audit --generate-script      # Create AppleScript for batch operations
    """) 